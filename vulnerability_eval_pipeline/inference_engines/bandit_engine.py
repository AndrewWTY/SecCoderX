"""
Bandit Static Analysis Engine for Vulnerability Detection
Provides Bandit-based static analysis as a baseline for comparison with LLM approaches.
Python-only static analysis using AST parsing.
"""

import json
import os
import signal
import subprocess
import tempfile
import shutil
import threading
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from concurrent.futures import ThreadPoolExecutor, wait, FIRST_COMPLETED
from tqdm import tqdm

from .base import BaseInferenceEngine, InferenceResult


# Global flag for graceful shutdown
_shutdown_requested = threading.Event()


@dataclass
class BanditConfig:
    """Configuration for Bandit analysis"""
    bandit_path: str
    threads: int
    timeout: int
    temp_dir: Optional[str]


class BanditEngine(BaseInferenceEngine):
    """
    Inference engine using Bandit for Python static analysis vulnerability detection.

    Unlike LLM engines, Bandit:
    - Doesn't use prompts or templates
    - Analyzes Python code directly via AST analysis
    - Produces deterministic results (no temperature/sampling)
    - Only supports Python language

    Key differences from CodeQL:
    - Python-only (no multi-language support)
    - No database creation step (direct AST analysis)
    - Much faster (~1-2 seconds per snippet vs ~10-30 seconds for CodeQL)
    - JSON output format
    """

    # Python language identifiers (language_suffix and language_name variations)
    PYTHON_IDENTIFIERS = {'python', 'Python', 'py', 'PY', '.py'}

    def __init__(
        self,
        bandit_path: str = None,
        threads: int = 8,
        timeout: int = 60,
        temp_dir: str = None,
        output_model_name: str = None,
        **kwargs  # Accept and ignore LLM-specific kwargs like template
    ):
        """
        Initialize the Bandit engine.

        Args:
            bandit_path: Path to bandit CLI (auto-detect if None)
            threads: Number of parallel analysis threads
            timeout: Timeout per code snippet (seconds)
            temp_dir: Custom temporary directory
            output_model_name: Name for output files
        """
        # Bandit doesn't use templates, pass None to parent
        super().__init__(
            template=None,
            system_prompt_file=None,
            output_model_name=output_model_name or 'bandit-security',
            max_prompt_tokens=None
        )

        # Find and validate Bandit CLI
        self.bandit_path = bandit_path or self._find_bandit()
        self._validate_bandit()

        # Store configuration
        self.config = BanditConfig(
            bandit_path=self.bandit_path,
            threads=threads,
            timeout=timeout,
            temp_dir=temp_dir
        )

        self.logger.info(f"Initialized Bandit engine")
        self.logger.info(f"  Bandit path: {self.bandit_path}")
        self.logger.info(f"  Parallel threads: {threads}")

    def _find_bandit(self) -> str:
        """Auto-detect Bandit CLI path"""
        # Try common locations
        common_paths = [
            'bandit',  # In PATH
            os.path.expanduser('~/.local/bin/bandit'),
            '/usr/local/bin/bandit',
            '/usr/bin/bandit',
        ]

        for path in common_paths:
            try:
                result = subprocess.run(
                    [path, '--version'],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                if result.returncode == 0:
                    self.logger.info(f"Found Bandit at: {path}")
                    return path
            except (subprocess.TimeoutExpired, FileNotFoundError, PermissionError):
                continue

        raise RuntimeError(
            "Bandit CLI not found. Please install Bandit:\n"
            "  pip install bandit\n"
            "Or specify --bandit_path /path/to/bandit"
        )

    def _validate_bandit(self) -> None:
        """Validate Bandit installation"""
        try:
            result = subprocess.run(
                [self.bandit_path, '--version'],
                capture_output=True,
                text=True,
                timeout=10
            )
            if result.returncode != 0:
                raise RuntimeError(f"Bandit validation failed: {result.stderr}")
            self.logger.info(f"Bandit version: {result.stdout.strip()}")
        except subprocess.TimeoutExpired:
            raise RuntimeError("Bandit validation timed out")
        except FileNotFoundError:
            raise RuntimeError(f"Bandit not found at: {self.bandit_path}")

    def _is_python(self, language: str) -> bool:
        """Check if the language identifier is Python"""
        return language in self.PYTHON_IDENTIFIERS

    def _prepare_code_snippet(
        self,
        code: str,
        index: int,
        base_temp_dir: str
    ) -> str:
        """
        Write code snippet to a temporary Python file for Bandit analysis.

        Returns:
            Path to the temporary Python file
        """
        # Create unique directory for this snippet
        snippet_dir = os.path.join(base_temp_dir, f"snippet_{index}")
        os.makedirs(snippet_dir, exist_ok=True)

        # Write code to file
        source_file = os.path.join(snippet_dir, f"code.py")
        with open(source_file, 'w', encoding='utf-8') as f:
            f.write(code)

        return source_file

    def _run_subprocess_interruptible(
        self,
        cmd: List[str],
        timeout: int,
        operation_name: str
    ) -> Tuple[bool, str, str]:
        """
        Run a subprocess with support for graceful interruption.

        Returns:
            Tuple of (success: bool, stdout: str, error_message: str)
        """
        global _shutdown_requested

        # Check if shutdown already requested
        if _shutdown_requested.is_set():
            return False, "", "Shutdown requested"

        process = None
        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            # Poll with small intervals to check shutdown flag
            elapsed = 0
            poll_interval = 0.5
            while elapsed < timeout:
                if _shutdown_requested.is_set():
                    # Terminate the process
                    process.terminate()
                    try:
                        process.wait(timeout=2)
                    except subprocess.TimeoutExpired:
                        process.kill()
                        process.wait()
                    return False, "", "Shutdown requested"

                retcode = process.poll()
                if retcode is not None:
                    # Process finished
                    stdout, stderr = process.communicate()
                    # Bandit returns non-zero when it finds issues, which is expected
                    # Return code 0: no issues, 1: issues found, other: error
                    if retcode in (0, 1):
                        return True, stdout, ""
                    return False, stdout, f"{operation_name} failed: {stderr[:200]}"

                import time
                time.sleep(poll_interval)
                elapsed += poll_interval

            # Timeout reached
            process.terminate()
            try:
                process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                process.kill()
                process.wait()
            return False, "", f"{operation_name} timed out"

        except Exception as e:
            if process is not None:
                try:
                    process.kill()
                    process.wait()
                except:
                    pass
            return False, "", f"{operation_name} error: {str(e)}"

    def _run_analysis(self, source_file: str) -> Tuple[bool, str, str]:
        """
        Run Bandit analysis on a Python file.
        Output results in JSON format for parsing.

        Returns:
            Tuple of (success: bool, json_output: str, error_message: str)
        """
        cmd = [
            self.bandit_path,
            '-f', 'json',  # JSON output format
            '-q',  # Quiet mode (only show results)
            source_file
        ]

        return self._run_subprocess_interruptible(
            cmd, self.config.timeout, "Bandit analysis"
        )

    def _parse_json_results(self, json_output: str) -> Dict[str, Any]:
        """
        Parse Bandit JSON results - check if any entries exist in results array.

        JSON structure:
        {
            "errors": [],
            "generated_at": "...",
            "metrics": {...},
            "results": [...]  # Security findings
        }

        If any entry in results array -> vulnerable.

        Returns:
            Dict with: is_vulnerable, findings_count, error
        """
        try:
            if not json_output or not json_output.strip():
                # Empty output means no findings
                return {
                    'is_vulnerable': False,
                    'findings_count': 0,
                    'error': None
                }

            data = json.loads(json_output)
            results = data.get('results', [])
            findings_count = len(results)

            return {
                'is_vulnerable': findings_count > 0,
                'findings_count': findings_count,
                'error': None
            }

        except json.JSONDecodeError as e:
            return {
                'is_vulnerable': False,
                'findings_count': 0,
                'error': f"JSON parse error: {str(e)}"
            }
        except Exception as e:
            return {
                'is_vulnerable': False,
                'findings_count': 0,
                'error': str(e)
            }

    def _result_to_response(self, analysis_result: Dict[str, Any]) -> str:
        """
        Convert Bandit analysis result to evaluator-compatible response.

        Uses [[YES]]/[[NO]] format for compatibility with existing evaluator.
        Simple logic: any entries in results array -> vulnerable
        """
        error = analysis_result.get('error')
        if error:
            return f"[ANALYSIS_ERROR: {error}] Unable to determine vulnerability status."

        is_vulnerable = analysis_result.get('is_vulnerable', False)
        findings_count = analysis_result.get('findings_count', 0)

        if is_vulnerable:
            return f"[[YES]]\n\nBandit detected {findings_count} security issue(s)."
        else:
            return "[[NO]]\n\nBandit did not detect any security vulnerabilities."

    def _analyze_single_snippet(
        self,
        code: str,
        language: str,
        index: int,
        base_temp_dir: str
    ) -> Dict[str, Any]:
        """Analyze a single code snippet end-to-end."""
        global _shutdown_requested

        # Check if shutdown requested before starting
        if _shutdown_requested.is_set():
            return {
                'is_vulnerable': False,
                'findings_count': 0,
                'error': 'Shutdown requested'
            }

        # Check if Python
        if not self._is_python(language):
            return {
                'is_vulnerable': False,
                'findings_count': 0,
                'error': f'Unsupported language: {language} (Bandit only supports Python)'
            }

        # Path for this snippet
        snippet_dir = os.path.join(base_temp_dir, f"snippet_{index}")

        try:
            # Step 1: Write code to temp file
            source_file = self._prepare_code_snippet(code, index, base_temp_dir)

            # Step 2: Run Bandit analysis (outputs JSON)
            success, json_output, error = self._run_analysis(source_file)
            if not success:
                return {'is_vulnerable': False, 'findings_count': 0, 'error': error}

            # Step 3: Parse JSON results (any entry = vulnerable)
            return self._parse_json_results(json_output)

        finally:
            # Cleanup snippet-specific files
            if os.path.exists(snippet_dir):
                shutil.rmtree(snippet_dir, ignore_errors=True)

    def run_inference(
        self,
        prompts: List[str],
        temperature: float = 0.0,
        max_tokens: int = 4096,
        data: List[Dict[str, Any]] = None,
        **kwargs
    ) -> List[List[str]]:
        """
        Run Bandit analysis on code snippets.

        Note: Unlike LLM engines, Bandit requires the 'data' parameter
        containing 'code' and 'language_suffix' (or 'language_name') fields.

        Handles Ctrl+C gracefully by:
        - Cancelling pending futures
        - Terminating running subprocesses
        - Cleaning up temporary files
        """
        global _shutdown_requested
        _shutdown_requested.clear()

        if data is None:
            raise ValueError("Bandit engine requires 'data' parameter")

        base_temp_dir = tempfile.mkdtemp(
            prefix='bandit_analysis_',
            dir=self.config.temp_dir
        )

        responses = []
        executor = None
        pbar = None

        # Store original signal handler
        original_sigint = signal.getsignal(signal.SIGINT)
        original_sigterm = signal.getsignal(signal.SIGTERM)

        def signal_handler(signum, frame):
            """Handle interrupt signals gracefully"""
            self.logger.warning("\nInterrupt received. Shutting down gracefully...")
            _shutdown_requested.set()
            # Restore original handler to allow force quit on second Ctrl+C
            signal.signal(signal.SIGINT, original_sigint)
            signal.signal(signal.SIGTERM, original_sigterm)

        try:
            # Install signal handlers
            signal.signal(signal.SIGINT, signal_handler)
            signal.signal(signal.SIGTERM, signal_handler)

            executor = ThreadPoolExecutor(max_workers=self.config.threads)
            futures = {}

            for i, item in enumerate(data):
                if _shutdown_requested.is_set():
                    break
                code = item.get('code', '')
                # Use language_suffix for language detection, fallback to language_name
                language = item.get('language_suffix', item.get('language_name', 'python'))
                future = executor.submit(
                    self._analyze_single_snippet,
                    code, language, i, base_temp_dir
                )
                futures[future] = i

            # Collect results in order
            results = [None] * len(data)
            completed_count = 0

            pbar = tqdm(total=len(futures), desc="Bandit Analysis")

            pending = set(futures.keys())
            while pending and not _shutdown_requested.is_set():
                # Wait for at least one future to complete, with timeout to check shutdown flag
                done, pending = wait(pending, timeout=0.5, return_when=FIRST_COMPLETED)

                for future in done:
                    idx = futures[future]
                    try:
                        result = future.result(timeout=0.1)
                        results[idx] = self._result_to_response(result)
                    except Exception as e:
                        self.logger.error(f"Error analyzing snippet {idx}: {e}")
                        results[idx] = f"[ANALYSIS_ERROR: {e}]"

                    completed_count += 1
                    pbar.update(1)

            # Handle shutdown - cancel remaining futures
            if _shutdown_requested.is_set():
                self.logger.warning(f"Cancelling {len(pending)} pending tasks...")
                for future in pending:
                    future.cancel()
                # Fill remaining results with error message
                for future in pending:
                    idx = futures[future]
                    if results[idx] is None:
                        results[idx] = "[ANALYSIS_CANCELLED: Shutdown requested]"
                pbar.close()
                raise KeyboardInterrupt("Analysis interrupted by user")

            pbar.close()

            # Filter out None results (shouldn't happen but be safe)
            responses = [[r if r is not None else "[ANALYSIS_ERROR: Unknown error]"] for r in results]

        except KeyboardInterrupt:
            self.logger.warning("Bandit analysis interrupted by user")
            raise
        finally:
            # Restore original signal handlers
            signal.signal(signal.SIGINT, original_sigint)
            signal.signal(signal.SIGTERM, original_sigterm)

            # Shutdown executor
            if executor is not None:
                self.logger.info("Shutting down thread pool...")
                executor.shutdown(wait=False, cancel_futures=True)

            # Close progress bar if still open
            if pbar is not None:
                try:
                    pbar.close()
                except:
                    pass

            # Clean up temp directory
            self.logger.info("Cleaning up temporary files...")
            shutil.rmtree(base_temp_dir, ignore_errors=True)

            self.logger.info("Cleanup complete")

        return responses

    def run_inference_pipeline(
        self,
        data_path: str,
        output_dir: str,
        temperature: float = 0.0,
        max_tokens: int = 4096,
        max_samples: int = None,
        seed: int = 42,
        balanced_sampling: bool = True,
        prompt_column: str = None,
        num_samples: int = 1,
        **kwargs
    ) -> InferenceResult:
        """Run complete Bandit analysis pipeline."""

        # Setup output directory
        dataset_name = os.path.splitext(os.path.basename(data_path))[0]
        dataset_output_dir = os.path.join(output_dir, dataset_name)
        os.makedirs(dataset_output_dir, exist_ok=True)

        # Load data
        self.logger.info(f"Loading data from {data_path}")
        data = self.load_data(data_path)
        original_count = len(data)

        # Check for unsupported languages (use language_suffix, fallback to language_name)
        python_count = 0
        non_python_languages = set()
        for item in data:
            lang = item.get('language_suffix', item.get('language_name', ''))
            if self._is_python(lang):
                python_count += 1
            else:
                non_python_languages.add(lang)

        self.logger.info(f"Python samples: {python_count}")
        if non_python_languages:
            self.logger.warning(f"Non-Python languages (will be skipped): {non_python_languages}")

        if len(data) == 0:
            raise ValueError("No samples found in dataset")

        # Sample if requested
        if max_samples and len(data) > max_samples:
            if balanced_sampling:
                data = self.balanced_sample(data, max_samples, seed)
            else:
                data = data[:max_samples]
            self.logger.info(f"Sampled to {len(data)} samples")

        # Create placeholder prompts (Bandit doesn't use prompts but format needs them)
        prompts = [f"[Bandit Analysis #{i}]" for i in range(len(data))]

        # Run analysis
        self.logger.info(f"Starting Bandit analysis on {len(data)} samples...")
        responses = self.run_inference(prompts=prompts, data=data)

        # Create result
        result = InferenceResult(
            prompts=prompts,
            responses=responses,
            metadata=data
        )

        # Save results
        model_name = self.output_model_name
        inference_file = os.path.join(
            dataset_output_dir,
            f"{model_name}_bandit_1_inference_results.jsonl"
        )

        inference_params = {
            'backend': 'bandit',
            'output_format': 'json',
            'threads': self.config.threads
        }

        self.save_inference_results(prompts, responses, data, inference_file, inference_params)
        self.logger.info(f"Results saved to {inference_file}")

        return result
