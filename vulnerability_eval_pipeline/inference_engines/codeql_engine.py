"""
CodeQL Static Analysis Engine for Vulnerability Detection
Provides CodeQL-based static analysis as a baseline for comparison with LLM approaches.
Supports all CodeQL languages (Python, JavaScript, Java, C/C++, C#, Go, Ruby, Swift).
"""

import csv
import json
import os
import signal
import subprocess
import tempfile
import shutil
import threading
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from concurrent.futures import ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED
from tqdm import tqdm

from .base import BaseInferenceEngine, InferenceResult


# Global flag for graceful shutdown
_shutdown_requested = threading.Event()


@dataclass
class CodeQLConfig:
    """Configuration for CodeQL analysis"""
    codeql_path: str
    threads: int
    timeout: int
    temp_dir: Optional[str]


class CodeQLEngine(BaseInferenceEngine):
    """
    Inference engine using CodeQL for static analysis vulnerability detection.

    Unlike LLM engines, CodeQL:
    - Doesn't use prompts or templates
    - Analyzes code directly via static analysis
    - Produces deterministic results (no temperature/sampling)
    - Supports all CodeQL languages (Python, JavaScript, Java, C/C++, C#, Go, Ruby, Swift)
    """

    # Map dataset language names/suffixes to CodeQL language identifiers
    # Covers language_name and language_suffix column values
    LANGUAGE_MAP = {
        # Python (language_name and language_suffix variations)
        'python': 'python',
        'Python': 'python',
        'py': 'python',
        # JavaScript/TypeScript
        'javascript': 'javascript',
        'JavaScript': 'javascript',
        'js': 'javascript',
        'JS': 'javascript',
        'typescript': 'javascript',  # CodeQL uses 'javascript' for both
        'TypeScript': 'javascript',
        'ts': 'javascript',
        # Java
        'java': 'java',
        'Java': 'java',
        # C/C++
        'c': 'cpp',
        'C': 'cpp',
        'cpp': 'cpp',
        'c++': 'cpp',
        'C++': 'cpp',
        'Cpp': 'cpp',
        # C#
        'csharp': 'csharp',
        'c#': 'csharp',
        'C#': 'csharp',
        'cs': 'csharp',
        # Go
        'go': 'go',
        'Go': 'go',
        'golang': 'go',
        # Ruby
        'ruby': 'ruby',
        'Ruby': 'ruby',
        'rb': 'ruby',
        # Swift
        'swift': 'swift',
        'Swift': 'swift',
    }


    # CodeQL security-extended query suites per language (only security-extended)
    QUERY_SUITES = {
        'python': 'codeql/python-queries:codeql-suites/python-security-extended.qls',
        'javascript': 'codeql/javascript-queries:codeql-suites/javascript-security-extended.qls',
        'java': 'codeql/java-queries:codeql-suites/java-security-extended.qls',
        'cpp': 'codeql/cpp-queries:codeql-suites/cpp-security-extended.qls',
        'csharp': 'codeql/csharp-queries:codeql-suites/csharp-security-extended.qls',
        'go': 'codeql/go-queries:codeql-suites/go-security-extended.qls',
        'ruby': 'codeql/ruby-queries:codeql-suites/ruby-security-extended.qls',
        'swift': 'codeql/swift-queries:codeql-suites/swift-security-extended.qls',
    }

    # File extensions per CodeQL language
    FILE_EXTENSIONS = {
        'python': '.py',
        'javascript': '.js',
        'java': '.java',
        'cpp': '.cpp',
        'csharp': '.cs',
        'go': '.go',
        'ruby': '.rb',
        'swift': '.swift',
    }

    # Languages that require build commands vs interpreted languages
    INTERPRETED_LANGUAGES = {'python', 'javascript', 'ruby'}

    # Compiled languages - use --command="true" for simple extraction without actual build
    COMPILED_LANGUAGES = {'java', 'cpp', 'csharp', 'go', 'swift'}

    def __init__(
        self,
        codeql_path: str = None,
        threads: int = 4,
        timeout: int = 300,
        temp_dir: str = None,
        output_model_name: str = None,
        **kwargs  # Accept and ignore LLM-specific kwargs like template
    ):
        """
        Initialize the CodeQL engine.

        Args:
            codeql_path: Path to codeql CLI (auto-detect if None)
            threads: Number of parallel analysis threads
            timeout: Timeout per code snippet (seconds)
            temp_dir: Custom temporary directory
            output_model_name: Name for output files
        """
        # CodeQL doesn't use templates, pass None to parent
        super().__init__(
            template=None,
            system_prompt_file=None,
            output_model_name=output_model_name or 'codeql-security',
            max_prompt_tokens=None
        )

        # Find and validate CodeQL CLI
        self.codeql_path = codeql_path or self._find_codeql()
        self._validate_codeql()

        # Store configuration
        self.config = CodeQLConfig(
            codeql_path=self.codeql_path,
            threads=threads,
            timeout=timeout,
            temp_dir=temp_dir
        )

        self.logger.info(f"Initialized CodeQL engine")
        self.logger.info(f"  CodeQL path: {self.codeql_path}")
        self.logger.info(f"  Query suite: security-extended (all languages)")
        self.logger.info(f"  Parallel threads: {threads}")

    def _find_codeql(self) -> str:
        """Auto-detect CodeQL CLI path"""
        # Try common locations
        common_paths = [
            'codeql',  # In PATH
            os.path.expanduser('~/codeql/codeql'),
            '/usr/local/bin/codeql',
            '/opt/codeql/codeql',
        ]

        for path in common_paths:
            try:
                result = subprocess.run(
                    [path, 'version'],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                if result.returncode == 0:
                    self.logger.info(f"Found CodeQL at: {path}")
                    return path
            except (subprocess.TimeoutExpired, FileNotFoundError, PermissionError):
                continue

        raise RuntimeError(
            "CodeQL CLI not found. Please install CodeQL and either:\n"
            "1. Add it to your PATH, or\n"
            "2. Specify --codeql_path /path/to/codeql"
        )

    def _validate_codeql(self) -> None:
        """Validate CodeQL installation"""
        try:
            result = subprocess.run(
                [self.codeql_path, 'version'],
                capture_output=True,
                text=True,
                timeout=10
            )
            if result.returncode != 0:
                raise RuntimeError(f"CodeQL validation failed: {result.stderr}")
            self.logger.info(f"CodeQL version: {result.stdout.strip()}")
        except subprocess.TimeoutExpired:
            raise RuntimeError("CodeQL validation timed out")
        except FileNotFoundError:
            raise RuntimeError(f"CodeQL not found at: {self.codeql_path}")

    def _get_codeql_language(self, language_name: str) -> Optional[str]:
        """Convert dataset language name to CodeQL language identifier"""
        return self.LANGUAGE_MAP.get(language_name)

    def _prepare_code_snippet(
        self,
        code: str,
        language: str,
        index: int,
        base_temp_dir: str
    ) -> Tuple[str, str]:
        """
        Write code snippet to a temporary file for CodeQL analysis.

        Returns:
            Tuple of (source_directory, source_file_path)
        """
        codeql_lang = self._get_codeql_language(language)
        extension = self.FILE_EXTENSIONS.get(codeql_lang, '.txt')

        # Create unique directory for this snippet
        snippet_dir = os.path.join(base_temp_dir, f"snippet_{index}")
        os.makedirs(snippet_dir, exist_ok=True)

        # Write code to file
        source_file = os.path.join(snippet_dir, f"code{extension}")
        with open(source_file, 'w', encoding='utf-8') as f:
            f.write(code)

        return snippet_dir, source_file

    def _run_subprocess_interruptible(
        self,
        cmd: List[str],
        timeout: int,
        operation_name: str
    ) -> Tuple[bool, str, str]:
        """
        Run a subprocess with support for graceful interruption.

        Returns:
            Tuple of (success: bool, stdout: str, error_message: str)
        """
        global _shutdown_requested

        # Check if shutdown already requested
        if _shutdown_requested.is_set():
            return False, "", "Shutdown requested"

        process = None
        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            # Poll with small intervals to check shutdown flag
            elapsed = 0
            poll_interval = 0.5
            while elapsed < timeout:
                if _shutdown_requested.is_set():
                    # Terminate the process
                    process.terminate()
                    try:
                        process.wait(timeout=2)
                    except subprocess.TimeoutExpired:
                        process.kill()
                        process.wait()
                    return False, "", "Shutdown requested"

                retcode = process.poll()
                if retcode is not None:
                    # Process finished
                    stdout, stderr = process.communicate()
                    if retcode != 0:
                        return False, stdout, f"{operation_name} failed: {stderr[:200]}"
                    return True, stdout, ""

                import time
                time.sleep(poll_interval)
                elapsed += poll_interval

            # Timeout reached
            process.terminate()
            try:
                process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                process.kill()
                process.wait()
            return False, "", f"{operation_name} timed out"

        except Exception as e:
            if process is not None:
                try:
                    process.kill()
                    process.wait()
                except:
                    pass
            return False, "", f"{operation_name} error: {str(e)}"

    def _create_database(
        self,
        source_dir: str,
        language: str,
        db_path: str
    ) -> Tuple[bool, str]:
        """
        Create CodeQL database for a code snippet.

        For interpreted languages (Python, JS, Ruby): simple extraction
        For compiled languages (Java, C++, C#, Go): use --command="true" to skip build

        Returns:
            Tuple of (success: bool, error_message: str)
        """
        codeql_lang = self._get_codeql_language(language)

        if not codeql_lang:
            return False, f"Unsupported language: {language}"

        cmd = [
            self.codeql_path,
            'database', 'create',
            db_path,
            f'--language={codeql_lang}',
            f'--source-root={source_dir}',
            '--overwrite',
            '--quiet'
        ]

        # For compiled languages, use a no-op build command
        # This extracts source code without requiring actual compilation
        if codeql_lang in self.COMPILED_LANGUAGES:
            cmd.append('--command=true')

        success, _, error = self._run_subprocess_interruptible(
            cmd, self.config.timeout, "Database creation"
        )
        return success, error

    def _run_analysis(
        self,
        db_path: str,
        language: str,
        csv_file: str
    ) -> Tuple[bool, str]:
        """
        Run CodeQL security-extended queries against a database.
        Output results to CSV format for simple detection.

        Returns:
            Tuple of (success: bool, error_message: str)
        """
        codeql_lang = self._get_codeql_language(language)
        query_suite = self.QUERY_SUITES.get(codeql_lang)

        if not query_suite:
            return False, f"No query suite for {language}"

        cmd = [
            self.codeql_path,
            'database', 'analyze',
            db_path,
            query_suite,
            '--format=csv',
            f'--output={csv_file}',
            '--quiet'
        ]

        success, _, error = self._run_subprocess_interruptible(
            cmd, self.config.timeout, "Analysis"
        )
        return success, error

    def _parse_csv_results(self, csv_file: str) -> Dict[str, Any]:
        """
        Parse CSV results - simply check if any entries exist.

        CSV format has header row, so >1 line means findings exist.
        If any entry exists -> vulnerable.

        Returns:
            Dict with: is_vulnerable, findings_count, error
        """
        try:
            with open(csv_file, 'r', encoding='utf-8') as f:
                reader = csv.reader(f)
                rows = list(reader)

            # First row is header, remaining rows are findings
            findings_count = max(0, len(rows) - 1)

            return {
                'is_vulnerable': findings_count > 0,
                'findings_count': findings_count,
                'error': None
            }

        except FileNotFoundError:
            # No output file means no findings
            return {
                'is_vulnerable': False,
                'findings_count': 0,
                'error': None
            }
        except Exception as e:
            return {
                'is_vulnerable': False,
                'findings_count': 0,
                'error': str(e)
            }

    def _result_to_response(self, analysis_result: Dict[str, Any]) -> str:
        """
        Convert CodeQL analysis result to evaluator-compatible response.

        Uses [[YES]]/[[NO]] format for compatibility with existing evaluator.
        Simple logic: any entries in CSV -> vulnerable
        """
        error = analysis_result.get('error')
        if error:
            return f"[ANALYSIS_ERROR: {error}] Unable to determine vulnerability status."

        is_vulnerable = analysis_result.get('is_vulnerable', False)
        findings_count = analysis_result.get('findings_count', 0)

        if is_vulnerable:
            return f"[[YES]]\n\nCodeQL detected {findings_count} security issue(s)."
        else:
            return "[[NO]]\n\nCodeQL did not detect any security vulnerabilities."

    def _analyze_single_snippet(
        self,
        code: str,
        language: str,
        index: int,
        base_temp_dir: str
    ) -> Dict[str, Any]:
        """Analyze a single code snippet end-to-end."""
        global _shutdown_requested

        # Check if shutdown requested before starting
        if _shutdown_requested.is_set():
            return {
                'is_vulnerable': False,
                'findings_count': 0,
                'error': 'Shutdown requested'
            }

        codeql_lang = self._get_codeql_language(language)
        if not codeql_lang:
            return {
                'is_vulnerable': False,
                'findings_count': 0,
                'error': f'Unsupported language: {language}'
            }

        # Paths for this snippet
        snippet_dir = os.path.join(base_temp_dir, f"snippet_{index}")
        db_dir = os.path.join(base_temp_dir, f"db_{index}")
        csv_file = os.path.join(base_temp_dir, f"results_{index}.csv")

        try:
            # Step 1: Write code to temp file
            self._prepare_code_snippet(code, language, index, base_temp_dir)

            # Step 2: Create CodeQL database
            success, error = self._create_database(snippet_dir, language, db_dir)
            if not success:
                return {'is_vulnerable': False, 'findings_count': 0, 'error': error}

            # Step 3: Run analysis (outputs CSV)
            success, error = self._run_analysis(db_dir, language, csv_file)
            if not success:
                return {'is_vulnerable': False, 'findings_count': 0, 'error': error}

            # Step 4: Parse CSV results (any entry = vulnerable)
            return self._parse_csv_results(csv_file)

        finally:
            # Cleanup snippet-specific files
            for path in [snippet_dir, db_dir]:
                if os.path.exists(path):
                    shutil.rmtree(path, ignore_errors=True)
            if os.path.exists(csv_file):
                try:
                    os.remove(csv_file)
                except:
                    pass

    def run_inference(
        self,
        prompts: List[str],
        temperature: float = 0.0,
        max_tokens: int = 4096,
        data: List[Dict[str, Any]] = None,
        **kwargs
    ) -> List[List[str]]:
        """
        Run CodeQL analysis on code snippets.

        Note: Unlike LLM engines, CodeQL requires the 'data' parameter
        containing 'code' and 'language_name' fields.

        Handles Ctrl+C gracefully by:
        - Cancelling pending futures
        - Terminating running subprocesses
        - Cleaning up temporary files
        """
        global _shutdown_requested
        _shutdown_requested.clear()

        if data is None:
            raise ValueError("CodeQL engine requires 'data' parameter")

        base_temp_dir = tempfile.mkdtemp(
            prefix='codeql_analysis_',
            dir=self.config.temp_dir
        )

        responses = []
        executor = None
        pbar = None

        # Store original signal handler
        original_sigint = signal.getsignal(signal.SIGINT)
        original_sigterm = signal.getsignal(signal.SIGTERM)

        def signal_handler(signum, frame):
            """Handle interrupt signals gracefully"""
            self.logger.warning("\nInterrupt received. Shutting down gracefully...")
            _shutdown_requested.set()
            # Restore original handler to allow force quit on second Ctrl+C
            signal.signal(signal.SIGINT, original_sigint)
            signal.signal(signal.SIGTERM, original_sigterm)

        try:
            # Install signal handlers
            signal.signal(signal.SIGINT, signal_handler)
            signal.signal(signal.SIGTERM, signal_handler)

            executor = ThreadPoolExecutor(max_workers=self.config.threads)
            futures = {}

            for i, item in enumerate(data):
                if _shutdown_requested.is_set():
                    break
                code = item.get('code', '')
                # Use language_suffix for CodeQL language detection
                language = item.get('language_suffix', item.get('language_name', 'python'))
                future = executor.submit(
                    self._analyze_single_snippet,
                    code, language, i, base_temp_dir
                )
                futures[future] = i

            # Collect results in order
            results = [None] * len(data)
            completed_count = 0

            pbar = tqdm(total=len(futures), desc="CodeQL Analysis")

            pending = set(futures.keys())
            while pending and not _shutdown_requested.is_set():
                # Wait for at least one future to complete, with timeout to check shutdown flag
                done, pending = wait(pending, timeout=0.5, return_when=FIRST_COMPLETED)

                for future in done:
                    idx = futures[future]
                    try:
                        result = future.result(timeout=0.1)
                        results[idx] = self._result_to_response(result)
                    except Exception as e:
                        self.logger.error(f"Error analyzing snippet {idx}: {e}")
                        results[idx] = f"[ANALYSIS_ERROR: {e}]"

                    completed_count += 1
                    pbar.update(1)

            # Handle shutdown - cancel remaining futures
            if _shutdown_requested.is_set():
                self.logger.warning(f"Cancelling {len(pending)} pending tasks...")
                for future in pending:
                    future.cancel()
                # Fill remaining results with error message
                for future in pending:
                    idx = futures[future]
                    if results[idx] is None:
                        results[idx] = "[ANALYSIS_CANCELLED: Shutdown requested]"
                pbar.close()
                raise KeyboardInterrupt("Analysis interrupted by user")

            pbar.close()

            # Filter out None results (shouldn't happen but be safe)
            responses = [[r if r is not None else "[ANALYSIS_ERROR: Unknown error]"] for r in results]

        except KeyboardInterrupt:
            self.logger.warning("CodeQL analysis interrupted by user")
            raise
        finally:
            # Restore original signal handlers
            signal.signal(signal.SIGINT, original_sigint)
            signal.signal(signal.SIGTERM, original_sigterm)

            # Shutdown executor
            if executor is not None:
                self.logger.info("Shutting down thread pool...")
                executor.shutdown(wait=False, cancel_futures=True)

            # Close progress bar if still open
            if pbar is not None:
                try:
                    pbar.close()
                except:
                    pass

            # Clean up temp directory
            self.logger.info("Cleaning up temporary files...")
            shutil.rmtree(base_temp_dir, ignore_errors=True)

            self.logger.info("Cleanup complete")

        return responses

    def run_inference_pipeline(
        self,
        data_path: str,
        output_dir: str,
        temperature: float = 0.0,
        max_tokens: int = 4096,
        max_samples: int = None,
        seed: int = 42,
        balanced_sampling: bool = True,
        prompt_column: str = None,
        num_samples: int = 1,
        **kwargs
    ) -> InferenceResult:
        """Run complete CodeQL analysis pipeline."""

        # Setup output directory
        dataset_name = os.path.splitext(os.path.basename(data_path))[0]
        dataset_output_dir = os.path.join(output_dir, dataset_name)
        os.makedirs(dataset_output_dir, exist_ok=True)

        # Load data
        self.logger.info(f"Loading data from {data_path}")
        data = self.load_data(data_path)
        original_count = len(data)

        # Check for unsupported languages and warn (use language_suffix, fallback to language_name)
        supported_languages = {}  # codeql_lang -> count
        unsupported_languages = set()
        for item in data:
            lang = item.get('language_suffix', item.get('language_name', ''))
            codeql_lang = self._get_codeql_language(lang)
            if codeql_lang:
                supported_languages[codeql_lang] = supported_languages.get(codeql_lang, 0) + 1
            else:
                unsupported_languages.add(lang)

        if supported_languages:
            lang_summary = ", ".join([f"{lang}: {count}" for lang, count in sorted(supported_languages.items())])
            self.logger.info(f"Languages to analyze: {lang_summary}")
        if unsupported_languages:
            self.logger.warning(f"Unsupported languages (will be skipped): {unsupported_languages}")

        if len(data) == 0:
            raise ValueError("No samples found in dataset")

        # Sample if requested
        if max_samples and len(data) > max_samples:
            if balanced_sampling:
                data = self.balanced_sample(data, max_samples, seed)
            else:
                data = data[:max_samples]
            self.logger.info(f"Sampled to {len(data)} samples")

        # Create placeholder prompts (CodeQL doesn't use prompts but format needs them)
        prompts = [f"[CodeQL Analysis #{i}]" for i in range(len(data))]

        # Run analysis
        self.logger.info(f"Starting CodeQL analysis on {len(data)} samples...")
        responses = self.run_inference(prompts=prompts, data=data)

        # Create result
        result = InferenceResult(
            prompts=prompts,
            responses=responses,
            metadata=data
        )

        # Save results
        model_name = self.output_model_name
        inference_file = os.path.join(
            dataset_output_dir,
            f"{model_name}_codeql_1_inference_results.jsonl"
        )

        inference_params = {
            'backend': 'codeql',
            'query_suite': 'security-extended',
            'output_format': 'csv',
            'threads': self.config.threads
        }

        self.save_inference_results(prompts, responses, data, inference_file, inference_params)
        self.logger.info(f"Results saved to {inference_file}")

        return result
